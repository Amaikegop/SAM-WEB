Backup por si se pausa de nuevo:

Creación de la Edge Function -> add_client/index.ts

En storage creación del guardado de pdfs del cliente -> client_docs (PUBLIC)

En Authentication creación manual del perfil del superadmin que sería la empresa con el mail de SAM.

########################################################################################################
########################################################################################################
########################################################################################################

$$$$$$$$$$ SQL $$$$$$$$$$$$$

-- TABLA PROFILES --
-- TABLES CREATION --

-- PROFILES
create table profiles (
  id uuid references auth.users on delete cascade,
  client_id character varying references client(id),
  role text check (role in ('superadmin', 'client_admin')) not null,
  primary key (id)
);

-- INSERT SUPERADMIN EN PROFILE
insert into profiles (id, role, client_id)
values (
  '2bf223de-3478-49ff-af34-0814e1610f86',
  'superadmin',
  null
);

alter table profiles add column email text;

########################################################################################################
########################################################################################################
########################################################################################################

-- POLITICAS RLS --

-- RLS

alter table client enable row level security;
alter table "user" enable row level security;
alter table appointment enable row level security;
alter table profiles enable row level security;
alter table service enable row level security;

########################################################################################################
########################################################################################################
########################################################################################################

-- POLITICAS DEL PERFIL SUPERADMIN --
-- SUPERADMIN --
create policy "superadmin can read clients"
on client
for select
using (
  exists (
    select 1 from profiles
    where profiles.id = auth.uid()
    and profiles.role = 'superadmin'
  )
);

create policy "superadmin can read users"
on "user"
for select
using (
  exists (
    select 1 from profiles
    where profiles.id = auth.uid()
    and profiles.role = 'superadmin'
  )
);

create policy "superadmin can read appointments"
on appointment
for select
using (
  exists (
    select 1 from profiles
    where profiles.id = auth.uid()
    and profiles.role = 'superadmin'
  )
);

CREATE POLICY "Allow select own profile"
ON profiles
FOR SELECT
USING ( auth.uid() = id );

CREATE POLICY "Allow insert from service role"
ON profiles
FOR INSERT
WITH CHECK (true);

CREATE POLICY "Allow insert from service role"
ON client
FOR INSERT
WITH CHECK (true);

########################################################################################################
########################################################################################################
########################################################################################################

-- CLIENT_ADMIN POLICIES

create policy "client can read his own users"
on public."user"
for SELECT
using (exists(
  select 1 from public.profiles p
  where p.id = auth.uid() and p.role = 'client_admin' and p.client_id = public."user".client_id
));

create policy "client manages own services"
on public.service
for all
using(
  exists(
    select 1 from public.profiles p
    where p.id = auth.uid() and p.role = 'client_admin' and p.client_id = service.client_id
  )
)
with check(
  exists(
    select 1 from public.profiles p
    where p.id = auth.uid() and p.role = 'client_admin' and p.client_id = service.client_id
  )
);

create policy "client_admin manages appointments of their users"
on public.appointment
for all
using (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'client_admin'
      and p.client_id = appointment.user_client_id
  )
)
with check (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'client_admin'
      and p.client_id = appointment.user_client_id
  )
);

########################################################################################################
########################################################################################################
########################################################################################################

-- VIEWS

create or replace view public.v_appointment_detail as
select
  a.id as appointment_id,
  a.start,
  a.service_id,
  s.name as service_name,
  a.user_id,
  u.fullname as user_fullname,
  a.user_client_id
from public.appointment a
join public.service s
  on s.id = a.service_id
join public."user" u
  on u.id = a.user_id;


########################################################################################################
########################################################################################################
########################################################################################################

-- MODIFICACIONES EN TABLE CLIENTE --
-- Table client

alter table client
add column created_at timestamptz not null default now();

alter table client
add column active boolean not null default true;

-- Table service

alter table service
add column name varchar not null default 'def service';


########################################################################################################
########################################################################################################
########################################################################################################
FUNCIONES

-- APPOINTMENT AVAILABILITY FUNCTION
create or replace function create_appointment_safe(
  p_service_id int,
  p_user_id text,
  p_client_id text,
  p_start timestamptz
)
returns json
language plpgsql
as $$
declare
  v_duration interval;
  v_simultaneous int;
  v_overlapping int;
begin
  -- Obtener duración y simultaneidad
  select duration, simultaneous
  into v_duration, v_simultaneous
  from service
  where id = p_service_id;

  if not found then
    return json_build_object(
      'ok', false,
      'reason', 'SERVICE_NOT_FOUND'
    );
  end if;

  -- Contar solapamientos
  select count(*)
  into v_overlapping
  from appointment a
  where a.service_id = p_service_id
    and a.user_client_id = p_client_id
    and a.start < p_start + v_duration
    and a.start + v_duration > p_start;

  if v_overlapping >= v_simultaneous then
    return json_build_object(
      'ok', false,
      'reason', 'NO_AVAILABILITY'
    );
  end if;

  -- Insertar turno
  insert into appointment (
    start,
    user_id,
    user_client_id,
    service_id
  )
  values (
    p_start,
    p_user_id,
    p_client_id,
    p_service_id
  );

  return json_build_object(
    'ok', true
  );
end;
$$;


-- PERMITIR RPC
grant execute on function create_appointment_safe to authenticated;
grant execute on function create_appointment_safe to anon;

-- DELETE SINGLE APPOINTMENT
create or replace function delete_appointment_safe(
  p_appointment_id int,
  p_client_id text
)
returns json
language plpgsql
as $$
declare
  v_exists boolean;
begin
  -- Verificar que el turno exista y pertenezca al cliente
  select true
  into v_exists
  from appointment
  where id = p_appointment_id
    and user_client_id = p_client_id;

  if not found then
    return json_build_object(
      'ok', false,
      'reason', 'NOT_FOUND_OR_FORBIDDEN'
    );
  end if;

  -- Eliminar turno
  delete from appointment
  where id = p_appointment_id
    and user_client_id = p_client_id;

  return json_build_object(
    'ok', true
  );
end;
$$;

grant execute on function delete_appointment_safe(int, text)
to anon, authenticated;

-- DELETE APPOINTMENTS OF A DAY
create or replace function delete_appointments_of_day(
  p_client_id text,
  p_date date,
  p_user_ids text[]
)
returns json
language plpgsql
as $$
declare
  v_count int;
begin
  delete from appointment
  where user_client_id = p_client_id
    and user_id = any(p_user_ids)
    and start >= p_date
    and start < p_date + interval '1 day';

  get diagnostics v_count = row_count;

  return json_build_object(
    'ok', true,
    'deleted', v_count
  );
end;
$$;

grant execute on function delete_appointments_of_day(text, date, text[])
to anon, authenticated;


--- UPDATE APPOINTMENT FUNCTION
create or replace function update_appointment_safe(
  p_appointment_id int,
  p_service_id int,
  p_user_id text,
  p_client_id text,
  p_start timestamptz
)
returns json
language plpgsql
security definer
set search_path = public
as $$
declare
  v_duration interval;
  v_simultaneous int;
  v_overlapping int;
begin
  if not exists (
    select 1
    from appointment
    where id = p_appointment_id
      and user_client_id = p_client_id
  ) then
    return json_build_object(
      'ok', false,
      'reason', 'NOT_FOUND_OR_FORBIDDEN'
    );
  end if;

  select duration, simultaneous
  into v_duration, v_simultaneous
  from service
  where id = p_service_id;

  if not found then
    return json_build_object(
      'ok', false,
      'reason', 'SERVICE_NOT_FOUND'
    );
  end if;

  select count(*)
  into v_overlapping
  from appointment a
  where a.service_id = p_service_id
    and a.user_client_id = p_client_id
    and a.id <> p_appointment_id
    and a.start < p_start + v_duration
    and a.start + v_duration > p_start;

  if v_overlapping >= v_simultaneous then
    return json_build_object(
      'ok', false,
      'reason', 'NO_AVAILABILITY'
    );
  end if;

  update appointment
  set
    start = p_start,
    service_id = p_service_id,
    user_id = p_user_id
  where id = p_appointment_id;

  return json_build_object('ok', true);
end;
$$;

grant execute on function update_appointment_safe(
  int, int, text, text, timestamptz
) to anon, authenticated;